{"ast":null,"code":"import { __awaiter } from \"tslib\";\nimport { DEFAULT_HEADERS } from './constants';\nimport { isStorageVectorsError } from './errors';\nimport { post } from './fetch';\nimport { resolveFetch } from './helpers';\n/**\n * @hidden\n * Base implementation for vector data operations.\n * Use {@link VectorIndexScope} via `supabase.storage.vectors.from('bucket').index('idx')` instead.\n */\nexport default class VectorDataApi {\n  /** Creates a new VectorDataApi instance */\n  constructor(url) {\n    let headers = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    let fetch = arguments.length > 2 ? arguments[2] : undefined;\n    this.shouldThrowOnError = false;\n    this.url = url.replace(/\\/$/, '');\n    this.headers = Object.assign(Object.assign({}, DEFAULT_HEADERS), headers);\n    this.fetch = resolveFetch(fetch);\n  }\n  /** Enable throwing errors instead of returning them in the response */\n  throwOnError() {\n    this.shouldThrowOnError = true;\n    return this;\n  }\n  /** Inserts or updates vectors in batch (1-500 per request) */\n  putVectors(options) {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        // Validate batch size\n        if (options.vectors.length < 1 || options.vectors.length > 500) {\n          throw new Error('Vector batch size must be between 1 and 500 items');\n        }\n        const data = yield post(this.fetch, \"\".concat(this.url, \"/PutVectors\"), options, {\n          headers: this.headers\n        });\n        return {\n          data: data || {},\n          error: null\n        };\n      } catch (error) {\n        if (this.shouldThrowOnError) {\n          throw error;\n        }\n        if (isStorageVectorsError(error)) {\n          return {\n            data: null,\n            error\n          };\n        }\n        throw error;\n      }\n    });\n  }\n  /** Retrieves vectors by their keys in batch */\n  getVectors(options) {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const data = yield post(this.fetch, \"\".concat(this.url, \"/GetVectors\"), options, {\n          headers: this.headers\n        });\n        return {\n          data,\n          error: null\n        };\n      } catch (error) {\n        if (this.shouldThrowOnError) {\n          throw error;\n        }\n        if (isStorageVectorsError(error)) {\n          return {\n            data: null,\n            error\n          };\n        }\n        throw error;\n      }\n    });\n  }\n  /** Lists vectors in an index with pagination */\n  listVectors(options) {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        // Validate segment configuration\n        if (options.segmentCount !== undefined) {\n          if (options.segmentCount < 1 || options.segmentCount > 16) {\n            throw new Error('segmentCount must be between 1 and 16');\n          }\n          if (options.segmentIndex !== undefined) {\n            if (options.segmentIndex < 0 || options.segmentIndex >= options.segmentCount) {\n              throw new Error(\"segmentIndex must be between 0 and \".concat(options.segmentCount - 1));\n            }\n          }\n        }\n        const data = yield post(this.fetch, \"\".concat(this.url, \"/ListVectors\"), options, {\n          headers: this.headers\n        });\n        return {\n          data,\n          error: null\n        };\n      } catch (error) {\n        if (this.shouldThrowOnError) {\n          throw error;\n        }\n        if (isStorageVectorsError(error)) {\n          return {\n            data: null,\n            error\n          };\n        }\n        throw error;\n      }\n    });\n  }\n  /** Queries for similar vectors using approximate nearest neighbor search */\n  queryVectors(options) {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const data = yield post(this.fetch, \"\".concat(this.url, \"/QueryVectors\"), options, {\n          headers: this.headers\n        });\n        return {\n          data,\n          error: null\n        };\n      } catch (error) {\n        if (this.shouldThrowOnError) {\n          throw error;\n        }\n        if (isStorageVectorsError(error)) {\n          return {\n            data: null,\n            error\n          };\n        }\n        throw error;\n      }\n    });\n  }\n  /** Deletes vectors by their keys in batch (1-500 per request) */\n  deleteVectors(options) {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        // Validate batch size\n        if (options.keys.length < 1 || options.keys.length > 500) {\n          throw new Error('Keys batch size must be between 1 and 500 items');\n        }\n        const data = yield post(this.fetch, \"\".concat(this.url, \"/DeleteVectors\"), options, {\n          headers: this.headers\n        });\n        return {\n          data: data || {},\n          error: null\n        };\n      } catch (error) {\n        if (this.shouldThrowOnError) {\n          throw error;\n        }\n        if (isStorageVectorsError(error)) {\n          return {\n            data: null,\n            error\n          };\n        }\n        throw error;\n      }\n    });\n  }\n}","map":{"version":3,"names":["DEFAULT_HEADERS","isStorageVectorsError","post","resolveFetch","VectorDataApi","constructor","url","headers","arguments","length","undefined","fetch","shouldThrowOnError","replace","Object","assign","throwOnError","putVectors","options","vectors","Error","data","concat","error","getVectors","listVectors","segmentCount","segmentIndex","queryVectors","deleteVectors","keys"],"sources":["C:\\Users\\Usuario\\Desktop\\intento de app\\node_modules\\@supabase\\storage-js\\src\\lib\\vectors\\VectorDataApi.ts"],"sourcesContent":["import { DEFAULT_HEADERS } from './constants'\nimport { isStorageVectorsError } from './errors'\nimport { Fetch, post } from './fetch'\nimport { resolveFetch } from './helpers'\nimport {\n  ApiResponse,\n  PutVectorsOptions,\n  GetVectorsOptions,\n  GetVectorsResponse,\n  DeleteVectorsOptions,\n  ListVectorsOptions,\n  ListVectorsResponse,\n  QueryVectorsOptions,\n  QueryVectorsResponse,\n} from './types'\n\n/**\n * @hidden\n * Base implementation for vector data operations.\n * Use {@link VectorIndexScope} via `supabase.storage.vectors.from('bucket').index('idx')` instead.\n */\nexport default class VectorDataApi {\n  protected url: string\n  protected headers: { [key: string]: string }\n  protected fetch: Fetch\n  protected shouldThrowOnError = false\n\n  /** Creates a new VectorDataApi instance */\n  constructor(url: string, headers: { [key: string]: string } = {}, fetch?: Fetch) {\n    this.url = url.replace(/\\/$/, '')\n    this.headers = { ...DEFAULT_HEADERS, ...headers }\n    this.fetch = resolveFetch(fetch)\n  }\n\n  /** Enable throwing errors instead of returning them in the response */\n  public throwOnError(): this {\n    this.shouldThrowOnError = true\n    return this\n  }\n\n  /** Inserts or updates vectors in batch (1-500 per request) */\n  async putVectors(options: PutVectorsOptions): Promise<ApiResponse<undefined>> {\n    try {\n      // Validate batch size\n      if (options.vectors.length < 1 || options.vectors.length > 500) {\n        throw new Error('Vector batch size must be between 1 and 500 items')\n      }\n\n      const data = await post(this.fetch, `${this.url}/PutVectors`, options, {\n        headers: this.headers,\n      })\n      return { data: data || {}, error: null }\n    } catch (error) {\n      if (this.shouldThrowOnError) {\n        throw error\n      }\n      if (isStorageVectorsError(error)) {\n        return { data: null, error }\n      }\n      throw error\n    }\n  }\n\n  /** Retrieves vectors by their keys in batch */\n  async getVectors(options: GetVectorsOptions): Promise<ApiResponse<GetVectorsResponse>> {\n    try {\n      const data = await post(this.fetch, `${this.url}/GetVectors`, options, {\n        headers: this.headers,\n      })\n      return { data, error: null }\n    } catch (error) {\n      if (this.shouldThrowOnError) {\n        throw error\n      }\n      if (isStorageVectorsError(error)) {\n        return { data: null, error }\n      }\n      throw error\n    }\n  }\n\n  /** Lists vectors in an index with pagination */\n  async listVectors(options: ListVectorsOptions): Promise<ApiResponse<ListVectorsResponse>> {\n    try {\n      // Validate segment configuration\n      if (options.segmentCount !== undefined) {\n        if (options.segmentCount < 1 || options.segmentCount > 16) {\n          throw new Error('segmentCount must be between 1 and 16')\n        }\n        if (options.segmentIndex !== undefined) {\n          if (options.segmentIndex < 0 || options.segmentIndex >= options.segmentCount) {\n            throw new Error(`segmentIndex must be between 0 and ${options.segmentCount - 1}`)\n          }\n        }\n      }\n\n      const data = await post(this.fetch, `${this.url}/ListVectors`, options, {\n        headers: this.headers,\n      })\n      return { data, error: null }\n    } catch (error) {\n      if (this.shouldThrowOnError) {\n        throw error\n      }\n      if (isStorageVectorsError(error)) {\n        return { data: null, error }\n      }\n      throw error\n    }\n  }\n\n  /** Queries for similar vectors using approximate nearest neighbor search */\n  async queryVectors(options: QueryVectorsOptions): Promise<ApiResponse<QueryVectorsResponse>> {\n    try {\n      const data = await post(this.fetch, `${this.url}/QueryVectors`, options, {\n        headers: this.headers,\n      })\n      return { data, error: null }\n    } catch (error) {\n      if (this.shouldThrowOnError) {\n        throw error\n      }\n      if (isStorageVectorsError(error)) {\n        return { data: null, error }\n      }\n      throw error\n    }\n  }\n\n  /** Deletes vectors by their keys in batch (1-500 per request) */\n  async deleteVectors(options: DeleteVectorsOptions): Promise<ApiResponse<undefined>> {\n    try {\n      // Validate batch size\n      if (options.keys.length < 1 || options.keys.length > 500) {\n        throw new Error('Keys batch size must be between 1 and 500 items')\n      }\n\n      const data = await post(this.fetch, `${this.url}/DeleteVectors`, options, {\n        headers: this.headers,\n      })\n      return { data: data || {}, error: null }\n    } catch (error) {\n      if (this.shouldThrowOnError) {\n        throw error\n      }\n      if (isStorageVectorsError(error)) {\n        return { data: null, error }\n      }\n      throw error\n    }\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}